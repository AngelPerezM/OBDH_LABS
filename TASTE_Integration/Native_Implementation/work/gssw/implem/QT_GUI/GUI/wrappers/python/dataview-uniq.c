/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"

const asn1SccSint hk_size = 4;
const asn1SccSint msg_size = 80;


flag T_UInt16_Equal(const T_UInt16* pVal1, const T_UInt16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt16_Initialize(T_UInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt16_ACN_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_ACN_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT16;

    return ret && T_UInt16_IsConstraintValid(pVal, pErrCode);
}



flag Analog_Data_Equal(const Analog_Data* pVal1, const Analog_Data* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Analog_Data_Initialize(Analog_Data* pVal)
{
	(void)pVal;


	T_UInt16_Initialize(pVal);
}

flag Analog_Data_IsConstraintValid(const Analog_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag Analog_Data_Encode(const Analog_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Analog_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = T_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Analog_Data_Decode(Analog_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = T_UInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret  && Analog_Data_IsConstraintValid(pVal, pErrCode);
}

flag Analog_Data_ACN_Encode(const Analog_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Analog_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = T_UInt16_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Analog_Data_ACN_Decode(Analog_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = T_UInt16_ACN_Decode(pVal, pBitStrm, pErrCode);

    return ret && Analog_Data_IsConstraintValid(pVal, pErrCode);
}



flag Analog_Data_Table_Equal(const Analog_Data_Table* pVal1, const Analog_Data_Table* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->obc_t == pVal2->obc_t);

    if (ret) {
        ret = (pVal1->obc_v == pVal2->obc_v);

    }

	return ret;

}

void Analog_Data_Table_Initialize(Analog_Data_Table* pVal)
{
	(void)pVal;



	/*set obc_t */
	T_UInt16_Initialize((&(pVal->obc_t)));
	/*set obc_v */
	T_UInt16_Initialize((&(pVal->obc_v)));
}

flag Analog_Data_Table_IsConstraintValid(const Analog_Data_Table* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt16_IsConstraintValid((&(pVal->obc_t)), pErrCode);
    if (ret) {
        ret = T_UInt16_IsConstraintValid((&(pVal->obc_v)), pErrCode);
    }

	return ret;
}

flag Analog_Data_Table_Encode(const Analog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Analog_Data_Table_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode obc_t */
	    ret = T_UInt16_Encode((&(pVal->obc_t)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode obc_v */
	        ret = T_UInt16_Encode((&(pVal->obc_v)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Analog_Data_Table_Decode(Analog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode obc_t */
	ret = T_UInt16_Decode((&(pVal->obc_t)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode obc_v */
	    ret = T_UInt16_Decode((&(pVal->obc_v)), pBitStrm, pErrCode);
	}

	return ret  && Analog_Data_Table_IsConstraintValid(pVal, pErrCode);
}

flag Analog_Data_Table_ACN_Encode(const Analog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Analog_Data_Table_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode obc_t */
	    ret = T_UInt16_ACN_Encode((&(pVal->obc_t)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode obc_v */
	        ret = T_UInt16_ACN_Encode((&(pVal->obc_v)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Analog_Data_Table_ACN_Decode(Analog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode obc_t */
	ret = T_UInt16_ACN_Decode((&(pVal->obc_t)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode obc_v */
	    ret = T_UInt16_ACN_Decode((&(pVal->obc_v)), pBitStrm, pErrCode);
	}


    return ret && Analog_Data_Table_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt64_Equal(const T_UInt64* pVal1, const T_UInt64* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt64_Initialize(T_UInt64* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT64; 

	return ret;
}

flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt64_ACN_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_ACN_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT64;

    return ret && T_UInt64_IsConstraintValid(pVal, pErrCode);
}



flag Mission_Time_Equal(const Mission_Time* pVal1, const Mission_Time* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Mission_Time_Initialize(Mission_Time* pVal)
{
	(void)pVal;


	T_UInt64_Initialize(pVal);
}

flag Mission_Time_IsConstraintValid(const Mission_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag Mission_Time_Encode(const Mission_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Mission_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = T_UInt64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Mission_Time_Decode(Mission_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = T_UInt64_Decode(pVal, pBitStrm, pErrCode);

	return ret  && Mission_Time_IsConstraintValid(pVal, pErrCode);
}

flag Mission_Time_ACN_Encode(const Mission_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Mission_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = T_UInt64_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Mission_Time_ACN_Decode(Mission_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = T_UInt64_ACN_Decode(pVal, pBitStrm, pErrCode);

    return ret && Mission_Time_IsConstraintValid(pVal, pErrCode);
}



flag Satellite_State_Equal(const Satellite_State* pVal1, const Satellite_State* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->timestamp == pVal2->timestamp);

    if (ret) {
        ret = Analog_Data_Table_Equal((&(pVal1->data)), (&(pVal2->data)));

    }

	return ret;

}

void Satellite_State_Initialize(Satellite_State* pVal)
{
	(void)pVal;



	/*set timestamp */
	T_UInt64_Initialize((&(pVal->timestamp)));
	/*set data */
	Analog_Data_Table_Initialize((&(pVal->data)));
}

flag Satellite_State_IsConstraintValid(const Satellite_State* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid((&(pVal->timestamp)), pErrCode);
    if (ret) {
        ret = Analog_Data_Table_IsConstraintValid((&(pVal->data)), pErrCode);
    }

	return ret;
}

flag Satellite_State_Encode(const Satellite_State* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Satellite_State_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode timestamp */
	    ret = T_UInt64_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = Analog_Data_Table_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Satellite_State_Decode(Satellite_State* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode timestamp */
	ret = T_UInt64_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = Analog_Data_Table_Decode((&(pVal->data)), pBitStrm, pErrCode);
	}

	return ret  && Satellite_State_IsConstraintValid(pVal, pErrCode);
}

flag Satellite_State_ACN_Encode(const Satellite_State* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Satellite_State_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode timestamp */
	    ret = T_UInt64_ACN_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = Analog_Data_Table_ACN_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Satellite_State_ACN_Decode(Satellite_State* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode timestamp */
	ret = T_UInt64_ACN_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = Analog_Data_Table_ACN_Decode((&(pVal->data)), pBitStrm, pErrCode);
	}


    return ret && Satellite_State_IsConstraintValid(pVal, pErrCode);
}



flag TM_Hello_Equal(const TM_Hello* pVal1, const TM_Hello* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->tm_timestamp == pVal2->tm_timestamp);

    if (ret) {
        ret = Satellite_State_Equal((&(pVal1->tm_payload)), (&(pVal2->tm_payload)));

    }

	return ret;

}

void TM_Hello_Initialize(TM_Hello* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	T_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	Satellite_State_Initialize((&(pVal->tm_payload)));
}

flag TM_Hello_IsConstraintValid(const TM_Hello* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = Satellite_State_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag TM_Hello_Encode(const TM_Hello* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Hello_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = Satellite_State_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Hello_Decode(TM_Hello* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = Satellite_State_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && TM_Hello_IsConstraintValid(pVal, pErrCode);
}

flag TM_Hello_ACN_Encode(const TM_Hello* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Hello_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_ACN_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = Satellite_State_ACN_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Hello_ACN_Decode(TM_Hello* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_ACN_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = Satellite_State_ACN_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}


    return ret && TM_Hello_IsConstraintValid(pVal, pErrCode);
}



flag TM_Housekeeping_Contents_Equal(const TM_Housekeeping_Contents* pVal1, const TM_Housekeeping_Contents* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 4; i1++) 
    {
    	ret = Satellite_State_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void TM_Housekeeping_Contents_Initialize(TM_Housekeeping_Contents* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    Satellite_State_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TM_Housekeeping_Contents_IsConstraintValid(const TM_Housekeeping_Contents* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 4; i1++) 
    {
    	ret = Satellite_State_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag TM_Housekeeping_Contents_Encode(const TM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)4) && ret; i1++) 
	    {
	    	ret = Satellite_State_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Housekeeping_Contents_Decode(TM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)4) && ret; i1++) 
	{
		ret = Satellite_State_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && TM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode);
}

flag TM_Housekeeping_Contents_ACN_Encode(const TM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)4) && ret; i1++) 
	    {
	    	ret = Satellite_State_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Housekeeping_Contents_ACN_Decode(TM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)4) && ret; i1++) 
	{
		ret = Satellite_State_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && TM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode);
}



flag TM_Housekeeping_Equal(const TM_Housekeeping* pVal1, const TM_Housekeeping* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->tm_timestamp == pVal2->tm_timestamp);

    if (ret) {
        ret = TM_Housekeeping_Contents_Equal((&(pVal1->tm_payload)), (&(pVal2->tm_payload)));

    }

	return ret;

}

void TM_Housekeeping_Initialize(TM_Housekeeping* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	T_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	TM_Housekeeping_Contents_Initialize((&(pVal->tm_payload)));
}

flag TM_Housekeeping_IsConstraintValid(const TM_Housekeeping* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = TM_Housekeeping_Contents_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag TM_Housekeeping_Encode(const TM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Housekeeping_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = TM_Housekeeping_Contents_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Housekeeping_Decode(TM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = TM_Housekeeping_Contents_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && TM_Housekeeping_IsConstraintValid(pVal, pErrCode);
}

flag TM_Housekeeping_ACN_Encode(const TM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Housekeeping_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_ACN_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = TM_Housekeeping_Contents_ACN_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Housekeeping_ACN_Decode(TM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_ACN_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = TM_Housekeeping_Contents_ACN_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}


    return ret && TM_Housekeeping_IsConstraintValid(pVal, pErrCode);
}



flag T_Float_Equal(const T_Float* pVal1, const T_Float* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Float_Initialize(T_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.3999999999999999612E+038 <= (*(pVal))) && ((*(pVal)) <= 3.3999999999999999612E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
}

flag T_Float_ACN_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_ACN_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLOAT;

    return ret && T_Float_IsConstraintValid(pVal, pErrCode);
}



flag T_B_b_T_Equal(const T_B_b_T* pVal1, const T_B_b_T* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 15; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void T_B_b_T_Initialize(T_B_b_T* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 15) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag T_B_b_T_IsConstraintValid(const T_B_b_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 15; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag T_B_b_T_Encode(const T_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? T_B_b_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)15) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_B_b_T_Decode(T_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)15) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && T_B_b_T_IsConstraintValid(pVal, pErrCode);
}

flag T_B_b_T_ACN_Encode(const T_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_B_b_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)15) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_B_b_T_ACN_Decode(T_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)15) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && T_B_b_T_IsConstraintValid(pVal, pErrCode);
}



flag T_Omega_Equal(const T_Omega* pVal1, const T_Omega* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void T_Omega_Initialize(T_Omega* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag T_Omega_IsConstraintValid(const T_Omega* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag T_Omega_Encode(const T_Omega* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? T_Omega_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Omega_Decode(T_Omega* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && T_Omega_IsConstraintValid(pVal, pErrCode);
}

flag T_Omega_ACN_Encode(const T_Omega* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_Omega_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Omega_ACN_Decode(T_Omega* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && T_Omega_IsConstraintValid(pVal, pErrCode);
}



flag T_MT_Working_Equal(const T_MT_Working* pVal1, const T_MT_Working* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void T_MT_Working_Initialize(T_MT_Working* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag T_MT_Working_IsConstraintValid(const T_MT_Working* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag T_MT_Working_Encode(const T_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? T_MT_Working_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_MT_Working_Decode(T_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && T_MT_Working_IsConstraintValid(pVal, pErrCode);
}

flag T_MT_Working_ACN_Encode(const T_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_MT_Working_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_MT_Working_ACN_Decode(T_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && T_MT_Working_IsConstraintValid(pVal, pErrCode);
}



flag T_Control_Equal(const T_Control* pVal1, const T_Control* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void T_Control_Initialize(T_Control* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag T_Control_IsConstraintValid(const T_Control* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag T_Control_Encode(const T_Control* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? T_Control_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Control_Decode(T_Control* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && T_Control_IsConstraintValid(pVal, pErrCode);
}

flag T_Control_ACN_Encode(const T_Control* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? T_Control_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Control_ACN_Decode(T_Control* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && T_Control_IsConstraintValid(pVal, pErrCode);
}



flag Operating_Mode_Equal(const Operating_Mode* pVal1, const Operating_Mode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Operating_Mode_Initialize(Operating_Mode* pVal)
{
	(void)pVal;


	(*(pVal)) = idle;
}

flag Operating_Mode_IsConstraintValid(const Operating_Mode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == idle)) || (((*(pVal)) == coverage)));
    *pErrCode = ret ? 0 :  ERR_OPERATING_MODE; 

	return ret;
}

flag Operating_Mode_Encode(const Operating_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Operating_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case idle:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case coverage:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_OPERATING_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Operating_Mode_Decode(Operating_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OPERATING_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = idle;
	                break;
	            case 1: 
	                (*(pVal)) = coverage;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_OPERATING_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = idle;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Operating_Mode_IsConstraintValid(pVal, pErrCode);
}

flag Operating_Mode_ACN_Encode(const Operating_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? Operating_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case idle:
	            uIntVal = 0;
	            break;
	        case coverage:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_OPERATING_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Operating_Mode_ACN_Decode(Operating_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OPERATING_MODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = idle;
	            break;
	        case 1:
	            (*(pVal)) = coverage;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_OPERATING_MODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Operating_Mode_IsConstraintValid(pVal, pErrCode);
}



flag TM_Mode_Equal(const TM_Mode* pVal1, const TM_Mode* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->tm_timestamp == pVal2->tm_timestamp);

    if (ret) {
        ret = (pVal1->tm_payload == pVal2->tm_payload);

    }

	return ret;

}

void TM_Mode_Initialize(TM_Mode* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	T_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	Operating_Mode_Initialize((&(pVal->tm_payload)));
}

flag TM_Mode_IsConstraintValid(const TM_Mode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = Operating_Mode_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag TM_Mode_Encode(const TM_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = Operating_Mode_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Mode_Decode(TM_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = Operating_Mode_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && TM_Mode_IsConstraintValid(pVal, pErrCode);
}

flag TM_Mode_ACN_Encode(const TM_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_ACN_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = Operating_Mode_ACN_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Mode_ACN_Decode(TM_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_ACN_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = Operating_Mode_ACN_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}


    return ret && TM_Mode_IsConstraintValid(pVal, pErrCode);
}



flag TC_Type_Equal(const TC_Type* pVal1, const TC_Type* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void TC_Type_Initialize(TC_Type* pVal)
{
	(void)pVal;


	(*(pVal)) = open_link;
}

flag TC_Type_IsConstraintValid(const TC_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == open_link)) || (((*(pVal)) == close_link)))) || (((*(pVal)) == request_hk)));
    *pErrCode = ret ? 0 :  ERR_TC_TYPE; 

	return ret;
}

flag TC_Type_Encode(const TC_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TC_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case open_link:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case close_link:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case request_hk:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TC_TYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC_Type_Decode(TC_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_TYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = open_link;
	                break;
	            case 1: 
	                (*(pVal)) = close_link;
	                break;
	            case 2: 
	                (*(pVal)) = request_hk;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TC_TYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = open_link;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && TC_Type_IsConstraintValid(pVal, pErrCode);
}

flag TC_Type_ACN_Encode(const TC_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? TC_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case open_link:
	            uIntVal = 0;
	            break;
	        case close_link:
	            uIntVal = 1;
	            break;
	        case request_hk:
	            uIntVal = 2;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TC_TYPE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 2);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC_Type_ACN_Decode(TC_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_TYPE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = open_link;
	            break;
	        case 1:
	            (*(pVal)) = close_link;
	            break;
	        case 2:
	            (*(pVal)) = request_hk;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TC_TYPE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && TC_Type_IsConstraintValid(pVal, pErrCode);
}



flag TM_Error_Contents_Equal(const TM_Error_Contents* pVal1, const TM_Error_Contents* pVal2)
{
	return (pVal1->nCount == pVal2->nCount) && (memcmp(pVal1->arr, pVal2->arr, pVal1->nCount) ==0)	;

}

void TM_Error_Contents_Initialize(TM_Error_Contents* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 80);
	pVal->nCount = 0;

}

flag TM_Error_Contents_IsConstraintValid(const TM_Error_Contents* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 80);
    *pErrCode = ret ? 0 :  ERR_TM_ERROR_CONTENTS; 

	return ret;
}

flag TM_Error_Contents_Encode(const TM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Error_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 80);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Error_Contents_Decode(TM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 80);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_ERROR_CONTENTS;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_ERROR_CONTENTS;
	}

	return ret  && TM_Error_Contents_IsConstraintValid(pVal, pErrCode);
}

flag TM_Error_Contents_ACN_Encode(const TM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Error_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 80);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Error_Contents_ACN_Decode(TM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 80);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TM_ERROR_CONTENTS;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_TM_ERROR_CONTENTS;
	}

    return ret && TM_Error_Contents_IsConstraintValid(pVal, pErrCode);
}



flag TM_Error_Equal(const TM_Error* pVal1, const TM_Error* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->tm_timestamp == pVal2->tm_timestamp);

    if (ret) {
        ret = TM_Error_Contents_Equal((&(pVal1->tm_payload)), (&(pVal2->tm_payload)));

    }

	return ret;

}

void TM_Error_Initialize(TM_Error* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	T_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	TM_Error_Contents_Initialize((&(pVal->tm_payload)));
}

flag TM_Error_IsConstraintValid(const TM_Error* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = TM_Error_Contents_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag TM_Error_Encode(const TM_Error* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Error_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = TM_Error_Contents_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Error_Decode(TM_Error* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = TM_Error_Contents_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && TM_Error_IsConstraintValid(pVal, pErrCode);
}

flag TM_Error_ACN_Encode(const TM_Error* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Error_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = T_UInt64_ACN_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = TM_Error_Contents_ACN_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Error_ACN_Decode(TM_Error* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = T_UInt64_ACN_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = TM_Error_Contents_ACN_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}


    return ret && TM_Error_IsConstraintValid(pVal, pErrCode);
}



flag TM_Type_Equal(const TM_Type* pVal1, const TM_Type* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case hello_PRESENT:
    		ret = TM_Hello_Equal((&(pVal1->u.hello)), (&(pVal2->u.hello)));
    		break;
    	case hk_PRESENT:
    		ret = TM_Housekeeping_Equal((&(pVal1->u.hk)), (&(pVal2->u.hk)));
    		break;
    	case mode_PRESENT:
    		ret = TM_Mode_Equal((&(pVal1->u.mode)), (&(pVal2->u.mode)));
    		break;
    	case err_PRESENT:
    		ret = TM_Error_Equal((&(pVal1->u.err)), (&(pVal2->u.err)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

void TM_Type_Initialize(TM_Type* pVal)
{
	(void)pVal;


	/*set hello*/
	pVal->kind = hello_PRESENT;
	TM_Hello_Initialize((&(pVal->u.hello)));
}

flag TM_Type_IsConstraintValid(const TM_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == hello_PRESENT) {
    	ret = TM_Hello_IsConstraintValid((&(pVal->u.hello)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == hk_PRESENT) {
        	ret = TM_Housekeeping_IsConstraintValid((&(pVal->u.hk)), pErrCode);
        }
        if (ret) {
            if (pVal->kind == mode_PRESENT) {
            	ret = TM_Mode_IsConstraintValid((&(pVal->u.mode)), pErrCode);
            }
            if (ret) {
                if (pVal->kind == err_PRESENT) {
                	ret = TM_Error_IsConstraintValid((&(pVal->u.err)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag TM_Type_Encode(const TM_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? TM_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case hello_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = TM_Hello_Encode((&(pVal->u.hello)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case hk_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = TM_Housekeeping_Encode((&(pVal->u.hk)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case mode_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = TM_Mode_Encode((&(pVal->u.mode)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case err_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = TM_Error_Encode((&(pVal->u.err)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_TM_TYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Type_Decode(TM_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint TM_Type_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &TM_Type_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_TYPE;
	if (ret) {
	    switch(TM_Type_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = hello_PRESENT;
	    	ret = TM_Hello_Decode((&(pVal->u.hello)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = hk_PRESENT;
	    	ret = TM_Housekeeping_Decode((&(pVal->u.hk)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = mode_PRESENT;
	    	ret = TM_Mode_Decode((&(pVal->u.mode)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = err_PRESENT;
	    	ret = TM_Error_Decode((&(pVal->u.err)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_TM_TYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && TM_Type_IsConstraintValid(pVal, pErrCode);
}

flag TM_Type_ACN_Encode(const TM_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? TM_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case hello_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = TM_Hello_ACN_Encode((&(pVal->u.hello)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case hk_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = TM_Housekeeping_ACN_Encode((&(pVal->u.hk)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case mode_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = TM_Mode_ACN_Encode((&(pVal->u.mode)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case err_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = TM_Error_ACN_Encode((&(pVal->u.err)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_TM_TYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Type_ACN_Decode(TM_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint NATIVE_IMPLEMENTATION_DATAVIEW_TM_Type_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &NATIVE_IMPLEMENTATION_DATAVIEW_TM_Type_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TM_TYPE;
	if (ret) {
	    switch(NATIVE_IMPLEMENTATION_DATAVIEW_TM_Type_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = hello_PRESENT;
	    	ret = TM_Hello_ACN_Decode((&(pVal->u.hello)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = hk_PRESENT;
	    	ret = TM_Housekeeping_ACN_Decode((&(pVal->u.hk)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = mode_PRESENT;
	    	ret = TM_Mode_ACN_Decode((&(pVal->u.mode)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = err_PRESENT;
	    	ret = TM_Error_ACN_Decode((&(pVal->u.err)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TM_TYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    } 
	} /*COVERAGE_IGNORE*/

    return ret && TM_Type_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

