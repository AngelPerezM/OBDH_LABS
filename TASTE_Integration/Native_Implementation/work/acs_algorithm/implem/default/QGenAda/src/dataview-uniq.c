/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "dataview-uniq.h"

const asn1SccSint hk_size = 4;
const asn1SccSint msg_size = 80;


void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag asn1SccT_UInt16_Encode(const asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt16_Decode(asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);
}



void asn1SccAnalog_Data_Initialize(asn1SccAnalog_Data* pVal)
{
	(void)pVal;


	asn1SccT_UInt16_Initialize(pVal);
}

flag asn1SccAnalog_Data_IsConstraintValid(const asn1SccAnalog_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccAnalog_Data_Encode(const asn1SccAnalog_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAnalog_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccT_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAnalog_Data_Decode(asn1SccAnalog_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccT_UInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccAnalog_Data_IsConstraintValid(pVal, pErrCode);
}



void asn1SccAnalog_Data_Table_Initialize(asn1SccAnalog_Data_Table* pVal)
{
	(void)pVal;



	/*set obc_t */
	asn1SccT_UInt16_Initialize((&(pVal->obc_t)));
	/*set obc_v */
	asn1SccT_UInt16_Initialize((&(pVal->obc_v)));
}

flag asn1SccAnalog_Data_Table_IsConstraintValid(const asn1SccAnalog_Data_Table* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->obc_t)), pErrCode);
    if (ret) {
        ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->obc_v)), pErrCode);
    }

	return ret;
}

flag asn1SccAnalog_Data_Table_Encode(const asn1SccAnalog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccAnalog_Data_Table_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode obc_t */
	    ret = asn1SccT_UInt16_Encode((&(pVal->obc_t)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode obc_v */
	        ret = asn1SccT_UInt16_Encode((&(pVal->obc_v)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccAnalog_Data_Table_Decode(asn1SccAnalog_Data_Table* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode obc_t */
	ret = asn1SccT_UInt16_Decode((&(pVal->obc_t)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode obc_v */
	    ret = asn1SccT_UInt16_Decode((&(pVal->obc_v)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccAnalog_Data_Table_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT64; 

	return ret;
}

flag asn1SccT_UInt64_Encode(const asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt64_Decode(asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);
}



void asn1SccMission_Time_Initialize(asn1SccMission_Time* pVal)
{
	(void)pVal;


	asn1SccT_UInt64_Initialize(pVal);
}

flag asn1SccMission_Time_IsConstraintValid(const asn1SccMission_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccMission_Time_Encode(const asn1SccMission_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMission_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    ret = asn1SccT_UInt64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMission_Time_Decode(asn1SccMission_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = asn1SccT_UInt64_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccMission_Time_IsConstraintValid(pVal, pErrCode);
}



void asn1SccSatellite_State_Initialize(asn1SccSatellite_State* pVal)
{
	(void)pVal;



	/*set timestamp */
	asn1SccT_UInt64_Initialize((&(pVal->timestamp)));
	/*set data */
	asn1SccAnalog_Data_Table_Initialize((&(pVal->data)));
}

flag asn1SccSatellite_State_IsConstraintValid(const asn1SccSatellite_State* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->timestamp)), pErrCode);
    if (ret) {
        ret = asn1SccAnalog_Data_Table_IsConstraintValid((&(pVal->data)), pErrCode);
    }

	return ret;
}

flag asn1SccSatellite_State_Encode(const asn1SccSatellite_State* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSatellite_State_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode timestamp */
	    ret = asn1SccT_UInt64_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccAnalog_Data_Table_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSatellite_State_Decode(asn1SccSatellite_State* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode timestamp */
	ret = asn1SccT_UInt64_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccAnalog_Data_Table_Decode((&(pVal->data)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccSatellite_State_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Hello_Initialize(asn1SccTM_Hello* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	asn1SccT_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	asn1SccSatellite_State_Initialize((&(pVal->tm_payload)));
}

flag asn1SccTM_Hello_IsConstraintValid(const asn1SccTM_Hello* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = asn1SccSatellite_State_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag asn1SccTM_Hello_Encode(const asn1SccTM_Hello* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Hello_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = asn1SccT_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = asn1SccSatellite_State_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Hello_Decode(asn1SccTM_Hello* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = asn1SccT_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = asn1SccSatellite_State_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTM_Hello_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Housekeeping_Contents_Initialize(asn1SccTM_Housekeeping_Contents* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    asn1SccSatellite_State_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccTM_Housekeeping_Contents_IsConstraintValid(const asn1SccTM_Housekeeping_Contents* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 4; i1++) 
    {
    	ret = asn1SccSatellite_State_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccTM_Housekeeping_Contents_Encode(const asn1SccTM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)4) && ret; i1++) 
	    {
	    	ret = asn1SccSatellite_State_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Housekeeping_Contents_Decode(asn1SccTM_Housekeeping_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)4) && ret; i1++) 
	{
		ret = asn1SccSatellite_State_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTM_Housekeeping_Contents_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Housekeeping_Initialize(asn1SccTM_Housekeeping* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	asn1SccT_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	asn1SccTM_Housekeeping_Contents_Initialize((&(pVal->tm_payload)));
}

flag asn1SccTM_Housekeeping_IsConstraintValid(const asn1SccTM_Housekeeping* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = asn1SccTM_Housekeeping_Contents_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag asn1SccTM_Housekeeping_Encode(const asn1SccTM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Housekeeping_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = asn1SccT_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = asn1SccTM_Housekeeping_Contents_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Housekeeping_Decode(asn1SccTM_Housekeeping* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = asn1SccT_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = asn1SccTM_Housekeeping_Contents_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTM_Housekeeping_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.3999999999999999612E+038 <= (*(pVal))) && ((*(pVal)) <= 3.3999999999999999612E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag asn1SccT_Float_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Float_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_B_b_T_Initialize(asn1SccT_B_b_T* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 15) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_B_b_T_IsConstraintValid(const asn1SccT_B_b_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 15; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_B_b_T_Encode(const asn1SccT_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_B_b_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)15) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_B_b_T_Decode(asn1SccT_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)15) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_B_b_T_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Omega_Initialize(asn1SccT_Omega* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_Omega_IsConstraintValid(const asn1SccT_Omega* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_Omega_Encode(const asn1SccT_Omega* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Omega_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Omega_Decode(asn1SccT_Omega* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_Omega_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_MT_Working_Initialize(asn1SccT_MT_Working* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_MT_Working_IsConstraintValid(const asn1SccT_MT_Working* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_MT_Working_Encode(const asn1SccT_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_MT_Working_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_MT_Working_Decode(asn1SccT_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_MT_Working_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Control_Initialize(asn1SccT_Control* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_Control_IsConstraintValid(const asn1SccT_Control* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_Control_Encode(const asn1SccT_Control* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Control_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Control_Decode(asn1SccT_Control* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_Control_IsConstraintValid(pVal, pErrCode);
}



void asn1SccOperating_Mode_Initialize(asn1SccOperating_Mode* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccidle;
}

flag asn1SccOperating_Mode_IsConstraintValid(const asn1SccOperating_Mode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == asn1Sccidle)) || (((*(pVal)) == asn1Scccoverage)));
    *pErrCode = ret ? 0 :  ERR_OPERATING_MODE; 

	return ret;
}

flag asn1SccOperating_Mode_Encode(const asn1SccOperating_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccOperating_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccidle:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Scccoverage:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_OPERATING_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOperating_Mode_Decode(asn1SccOperating_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OPERATING_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccidle;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Scccoverage;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_OPERATING_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccidle;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccOperating_Mode_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Mode_Initialize(asn1SccTM_Mode* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	asn1SccT_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	asn1SccOperating_Mode_Initialize((&(pVal->tm_payload)));
}

flag asn1SccTM_Mode_IsConstraintValid(const asn1SccTM_Mode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = asn1SccOperating_Mode_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag asn1SccTM_Mode_Encode(const asn1SccTM_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = asn1SccT_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = asn1SccOperating_Mode_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Mode_Decode(asn1SccTM_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = asn1SccT_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = asn1SccOperating_Mode_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTM_Mode_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTC_Type_Initialize(asn1SccTC_Type* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccopen_link;
}

flag asn1SccTC_Type_IsConstraintValid(const asn1SccTC_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == asn1Sccopen_link)) || (((*(pVal)) == asn1Sccclose_link)))) || (((*(pVal)) == asn1Sccrequest_hk)));
    *pErrCode = ret ? 0 :  ERR_TC_TYPE; 

	return ret;
}

flag asn1SccTC_Type_Encode(const asn1SccTC_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTC_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccopen_link:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccclose_link:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccrequest_hk:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TC_TYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC_Type_Decode(asn1SccTC_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_TYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccopen_link;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccclose_link;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccrequest_hk;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TC_TYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccopen_link;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccTC_Type_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Error_Contents_Initialize(asn1SccTM_Error_Contents* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 80);
	pVal->nCount = 0;

}

flag asn1SccTM_Error_Contents_IsConstraintValid(const asn1SccTM_Error_Contents* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->nCount <= 80);
    *pErrCode = ret ? 0 :  ERR_TM_ERROR_CONTENTS; 

	return ret;
}

flag asn1SccTM_Error_Contents_Encode(const asn1SccTM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Error_Contents_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 80);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Error_Contents_Decode(asn1SccTM_Error_Contents* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 80);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_ERROR_CONTENTS;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_ERROR_CONTENTS;
	}

	return ret  && asn1SccTM_Error_Contents_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Error_Initialize(asn1SccTM_Error* pVal)
{
	(void)pVal;



	/*set tm_timestamp */
	asn1SccT_UInt64_Initialize((&(pVal->tm_timestamp)));
	/*set tm_payload */
	asn1SccTM_Error_Contents_Initialize((&(pVal->tm_payload)));
}

flag asn1SccTM_Error_IsConstraintValid(const asn1SccTM_Error* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->tm_timestamp)), pErrCode);
    if (ret) {
        ret = asn1SccTM_Error_Contents_IsConstraintValid((&(pVal->tm_payload)), pErrCode);
    }

	return ret;
}

flag asn1SccTM_Error_Encode(const asn1SccTM_Error* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Error_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode tm_timestamp */
	    ret = asn1SccT_UInt64_Encode((&(pVal->tm_timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tm_payload */
	        ret = asn1SccTM_Error_Contents_Encode((&(pVal->tm_payload)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Error_Decode(asn1SccTM_Error* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode tm_timestamp */
	ret = asn1SccT_UInt64_Decode((&(pVal->tm_timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tm_payload */
	    ret = asn1SccTM_Error_Contents_Decode((&(pVal->tm_payload)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTM_Error_IsConstraintValid(pVal, pErrCode);
}



void asn1SccTM_Type_Initialize(asn1SccTM_Type* pVal)
{
	(void)pVal;


	/*set hello*/
	pVal->kind = hello_PRESENT;
	asn1SccTM_Hello_Initialize((&(pVal->u.hello)));
}

flag asn1SccTM_Type_IsConstraintValid(const asn1SccTM_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == hello_PRESENT) {
    	ret = asn1SccTM_Hello_IsConstraintValid((&(pVal->u.hello)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == hk_PRESENT) {
        	ret = asn1SccTM_Housekeeping_IsConstraintValid((&(pVal->u.hk)), pErrCode);
        }
        if (ret) {
            if (pVal->kind == mode_PRESENT) {
            	ret = asn1SccTM_Mode_IsConstraintValid((&(pVal->u.mode)), pErrCode);
            }
            if (ret) {
                if (pVal->kind == err_PRESENT) {
                	ret = asn1SccTM_Error_IsConstraintValid((&(pVal->u.err)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag asn1SccTM_Type_Encode(const asn1SccTM_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccTM_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind) 
	    {
	    case hello_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = asn1SccTM_Hello_Encode((&(pVal->u.hello)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case hk_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = asn1SccTM_Housekeeping_Encode((&(pVal->u.hk)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case mode_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = asn1SccTM_Mode_Encode((&(pVal->u.mode)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case err_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = asn1SccTM_Error_Encode((&(pVal->u.err)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_TM_TYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Type_Decode(asn1SccTM_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint asn1SccTM_Type_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &asn1SccTM_Type_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TM_TYPE;
	if (ret) {
	    switch(asn1SccTM_Type_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = hello_PRESENT;
	    	ret = asn1SccTM_Hello_Decode((&(pVal->u.hello)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = hk_PRESENT;
	    	ret = asn1SccTM_Housekeeping_Decode((&(pVal->u.hk)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = mode_PRESENT;
	    	ret = asn1SccTM_Mode_Decode((&(pVal->u.mode)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = err_PRESENT;
	    	ret = asn1SccTM_Error_Decode((&(pVal->u.err)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_TM_TYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && asn1SccTM_Type_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

